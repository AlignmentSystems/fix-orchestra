has_interface(stateMachine, package) ::= <<
package $package$;

import javax.annotation.processing.Generated;

/**
 * A stateful object with $stateMachine.name$
 */
@Generated(value="io.fixprotocol.orchestra.states.StateGenerator")
public interface Has$stateMachine.name$ {
  $stateMachine.name$ get$stateMachine.name$();
}
>>

transition_interface(stateMachine, package) ::= <<
package $package$;

import javax.annotation.processing.Generated;

/**
 * State transitions of an object with $stateMachine.name$
 */
@Generated(value="io.fixprotocol.orchestra.states.StateGenerator")
public interface $stateMachine.name$Transition {
  /**
   * @return Returns a guard expression for a transition
   */
  String getGuard();
  
  /**
   * @return Returns the state of an object before a transition
   */
  $stateMachine.name$ getSource();

  /**
   * @return Returns the state of an object after a transition
   */
  $stateMachine.name$ getTarget();
}
>>

state_enum(stateMachine, package) ::= <<
package $package$;

import javax.annotation.processing.Generated;

/**
 * Enumerated states of $stateMachine.name$
 */
@Generated(value="io.fixprotocol.orchestra.states.StateGenerator")
public enum $stateMachine.name$ {
  /** initial state */
  $state(stateMachine.initial, package)$
  $stateMachine.state:{state|$state(state, package)$}$;
  
  $initial(stateMachine, stateMachine.initial, package)$
}
>>

state(state, package) ::= <<
	$state.name$,
	
>>

initial(stateMachine, state, package) ::= <<
  public static $stateMachine.name$ getInitialState() {
    return $stateMachine.name$.$state.name$;
  }
>>

stateMachinePart1(stateMachine, package) ::= <<
package $package$;

import java.util.function.BiConsumer;
import javax.annotation.processing.Generated;
import io.fixprotocol.orchestra.dsl.antlr.Evaluator;
import io.fixprotocol.orchestra.dsl.antlr.ScoreException;
import io.fixprotocol.orchestra.model.FixValue;
import io.fixprotocol.orchestra.states.StateMachineException;

/**
 * A state machine for state $stateMachine.name$
 *
 * $documentation(object=stateMachine)$
 * @param <T> A stateful class with $stateMachine.name$
 */
@Generated(value="io.fixprotocol.orchestra.states.StateGenerator")
public class $stateMachine.name$StateMachine<T extends Has$stateMachine.name$> {

  /**
   * Attempt a state transition
   * <p>
   * The caller is responsible for setting symbols for the Score expression evaluator to evaluate.
   * </p>
   * 
   * @param event name of transition to attempt
   * @param stateOf object for which state is tracked
   * @param onEntry listener for entry to a new state
   * @param onExit listener for exit from old state, if a state change occurred.
   * @param evaluator expression evaluator
   * @return the state after transition event. May be same as current state.
   * @throws StateMachineException if the transition is invalid for current state
   * @throws ScoreException expression evaluation error
   */
  public $stateMachine.name$ tryTransition(String event, T stateOf, BiConsumer<$stateMachine.name$, T> onEntry,
      BiConsumer<$stateMachine.name$, T> onExit, Evaluator evaluator)
      throws StateMachineException, ScoreException {
    $stateMachine.name$Transition transition = null;
    $stateMachine.name$ currentState = stateOf.get$stateMachine.name$();

    try {
      switch (currentState) {
 >>
		
stateMachinePart2(stateMachine, package) ::= <<		
        default:
          throw new StateMachineException(
              String.format("Invalid transition %s from state %s", event, currentState.name()));
      }
    } catch (IllegalArgumentException e) {
      throw new StateMachineException("Invalid event", e);
    }
    
    boolean guarded = false;
    String guard = transition.getGuard();
    if (guard != null && !guard.isEmpty()) {
      FixValue<?> fixValue = evaluator.evaluate(guard);
      guarded = fixValue.getValue() != Boolean.TRUE;
    }
    if (!guarded) {
      $stateMachine.name$ newState = transition.getTarget();
      if (onExit != null && newState != currentState) {
        onExit.accept(currentState, stateOf);
      }
      if (onEntry != null && newState != currentState) {
        onEntry.accept(newState, stateOf);
      }

      return newState;
    }

    return currentState;
  }
}
>>

state_case(stateMachine, state, package) ::= <<
    case $state.name$:
      transition = $stateMachine.name$$state.name$Transition.valueOf(event);
      break;
      
>>

transition_enum(stateMachine, state, package) ::= <<
package $package$;

import javax.annotation.processing.Generated;

/**
 * Transitions from state $stateMachine.name$.$state.name$
 */
 @Generated(value="io.fixprotocol.orchestra.states.StateGenerator")
public enum $stateMachine.name$$state.name$Transition implements $stateMachine.name$Transition {
  $state.transition:{transition|$transition(stateMachine, transition, package)$}$;
    
  private final String guard;
  private final $stateMachine.name$ target;

  $stateMachine.name$$state.name$Transition($stateMachine.name$$transition.target.name$ target, String guard) {
    this.target = target;
    this.guard = guard;
  }

  public String getGuard() {
    return guard;
  }
  
  public $stateMachine.name$ getSource() {
    return $stateMachine.name$.$state.name$;
  }

  public $stateMachine.name$ getTarget() {
    return target;
  }
}
>>

transition(stateMachine, transition, package) ::= <<
	$transition.name$($stateMachine.name$.$transition.target$, "$transition.when$"),
	
>>

documentation(object) ::= <<
$object.annotation.DocumentationOrAppinfo:{doc|$if(doc.purpose)$<b>$doc.purpose$:</b> $endif$$doc.content$<br>}$
>>